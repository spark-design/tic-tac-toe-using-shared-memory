#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <errno.h>
#include <sys/shm.h>
#include <sys/sem.h>

#ifndef __sort_h__
#define __sort_h__

// DO NOT EDIT THIS FILE

#define NUMRECS (24)
int randomSeed  = 0;

union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
	struct seminfo *_buf;
	};

typedef struct sharedmem{
	int turn;
	int arr1[3][3];
} shamem;


typedef struct __rec_t {
    unsigned int key1;
    unsigned int key2;
    unsigned int playernum;
    unsigned int record[NUMRECS];
} rec_t;



#endif // __sort_h__

void
usage(char *prog) 
{
    fprintf(stderr, "usage: %s <-s random seed> <-n number of records> <-o output file>\n", prog);
    exit(1);
}

// Board taken from here: http://www.cprogrammingnotes.com/question/tic-tac-toe-game.html
/*
void display()
{
  	printf("     |     |     \n");		
    	printf("  %c  |  %c  |  %c \n", square[1], square[2], square[3]);

    	printf("_____|_____|_____\n");
    	printf("     |     |     \n");

    	printf("  %c  |  %c  |  %c \n", square[4], square[5], square[6]);

    	printf("_____|_____|_____\n");
    	printf("     |     |     \n");

    	printf("  %c  |  %c  |  %c \n", square[7], square[8], square[9]);

    	printf("     |     |     \n\n"); 
}*/

// player 1
void player1()
{
printf("test");

shamem s;
rec_t r;
// seed random number generator
srand(randomSeed);

  if (mkfifo("xoSync", S_IRWXU) == -1) 		// STEP 1(PLAYER 1): Attempt to create the FIFO xoSync. If the fifo already exists or is created, continue. 
  {
   if (errno != EEXIST)
   {
    perror("mkfifo");
    exit(EXIT_FAILURE);
    }
  } 
  
  int fd;
  char * myfifo = "xoSync";
  
  mkfifo(myfifo, 0666);
  
  r.key1 = rand() % (unsigned int) 0xFFFFFFFF;	// STEP 2(PLAYER 1): Generate two random numbers
  r.key2 = rand() % (unsigned int) 0xFFFFFFFF;	// STEP 2(PLAYER 1): Generate two random numbers
  printf("key 1: %d", r.key1);
  key_t key1 = ftok(myfifo, r.key1); 			// STEP 3(PLAYER 1): create 1st key using fifo and 1st random key value
  key_t key2 = ftok(myfifo, r.key2); 			// STEP 3(PLAYER 1): create 2nd key using fifo and 2nd random key value
  int shmid = shmget(key1,1024,0666|IPC_CREAT);	// STEP 3(PLAYER 1): use the first key generated as the projection value for shared memory
  int semid = semget(key2,2,0666|IPC_CREAT); 		// STEP 3(PLAYER 1)/STEP 5(PLAYER 1): Use the 2nd key generated as the projection value for semaphores. Create a semaphore with a set size of 2
  s.turn = shmat(shmid, NULL, 0); 			// STEP 4(PLAYER 1)/STEP 7(PLAYER 1): create shared memory and make sure to give it proper access permissions. Attach shmem to process and init
  int semctl(semid, 0, SETVAL 1); 			// STEP 6(PLAYER 1): player 1. Use setval to initialize player 1 as available
  int semctl(semid, 1, SETVAL 0;  			// STEP 6(PLAYER 1): player 2. Use setval to initialize player 2 as in use
  // fd = open(myfifo, O_WRONLY); 			// STEP 8(PLAYER 1): open the fifo for write
  // write(fd,r.key1,sizeof(input)); 			// STEP 9(PLAYER 1):write the random numbers you generated to the fifo. write them in order of generation.
  // write(fd,r.key2,sizeof(input)); 			// STEP 9(PLAYER 1):write the random numbers you generated to the fifo. write them in order of generation.
  // close(fd);   					// STEP 10(PLAYER 1): close the FIFO
  // 							// STEP 11(PLAYER 1): Enter the gameplay loop
  while(s.turn > -1){					// START OF GAMEPLAY LOOP
  	int semctl(semid, 0, SETVAL 1); 		// STEP 1(PLAYER 1): Reserve player 1's semaphore
	// display();					// STEP 2(PLAYER 1): Display the state of the game board
	//						// STEP 3(PLAYER 1): Make player 1's move
	// display();					// STEP 4(PLAYER 1): Display the state of the game board
	/* if(player1 == win || playsLeft == 0)	// STEP 5(PLAYER 1): If player 1 has won or no more plays exist, set the turn counter to -1
	{						// STEP 5(PLAYER 1): If player 1 has won or no more plays exist, set the turn counter to -1
		s.turn == -1;				// STEP 5(PLAYER 1): If player 1 has won or no more plays exist, set the turn counter to -1
	}*/						// STEP 5(PLAYER 1): If player 1 has won or no more plays exist, set the turn counter to -1
	// 						// STEP 6(PLAYER 1): Release player 2's semaphore
  }							// END OF GAMEPLAY LOOP
  // fd = open(myfifo, O_WRONLY);			// STEP 12(PLAYER 1): Open the FIFO xoSync for write
  // close(fd);					// STEP 13(PLAYER 1): Close the FIFO
  // shmdt(block)					// STEP 14(PLAYER 1): Detach the segment of shared memory
  // shmctl(shmid,IPC_RMID,NULL)			// STEP 15(PLAYER 1): Delete the shared memory and semaphores
  // semctl(semid, 0, IPC_RMID);			// STEP 15(PLAYER 1): Delete the shared memory and semaphores
  exit(EXIT_SUCCESS);
}

void player2()
{
  if (mkfifo("xoSync", S_IRWXU) == -1) 		// STEP 1(PLAYER 2): Attempt to create the FIFO xoSync. If the fifo already exists or is created, continue. 
  {
   if (errno != EEXIST)
   {
    perror("mkfifo");
    exit(EXIT_FAILURE);
    }
  }
  // fd = open(myfifo, O_RONLY); 			// STEP 2(PLAYER 2): open the fifo for read 
  // read(fd,2);					// STEP 3(PLAYER 2): read two integers from the fifo
  // close(fd):					// STEP 4(PLAYER 2): close the FIFO
  int shmid = shmget(key1,1024,0666|IPC_CREAT);	// STEP 5(PLAYER 2): use the first key generated as the projection value for shared memory
  int semid = semget(key2,2,0666|IPC_CREAT); 		// STEP 5(PLAYER 2): Use the 2nd key generated as the projection value for semaphores. 
  s.turn = shmat(shmid, NULL, 0); 			// STEP 6(PLAYER 2)/STEP 7(PLAYER 2): Retrieve the shared memory  and the semaphore set created by player 1. Attach the shared memory segment
  int semctl(semid, 0, SETVAL 1); 			// STEP 6(PLAYER 2): Retrieve the shared memory  and the semaphore set created by player 1
  int semctl(semid, 1, SETVAL 0;  			// STEP 6(PLAYER 2): Retrieve the shared memory  and the semaphore set created by player 1
  // while(1){					        // START OF GAMEPLAY LOOP. While true loop
  	int semctl(semid, 0, SETVAL 1); 		// STEP 1(PLAYER 2): Reserve player 1's semaphore
	// display();					// STEP 2(PLAYER 2): Display the state of the game board
	// if(s.turn == -1){
		break;
	
//	} 						// END OF GAMEPLAY LOOP
  // read(fd,2);					// STEP 9(PLAYER 2): Open the FIFO xoSync for read
  // close(fd);					// STEP 10(PLAYER 2): Close the FIFO
  // shmdt(block)					// STEP 11(PLAYER 2): Detach the segment of shared memory
}


int
main(int argc, char *argv[])
{
rec_t r;
int playernum = 0;
    // arguments
    int recordsLeft = 0;
    char *outFile   = "/no/such/file";

    // input params
    int c;
    opterr = 0;
    while ((c = getopt(argc, argv, "if:12")) != -1) {
	switch (c) {
	case '1': // if player one is chosen
	        printf("player 1");
	        r.playernum = 1;
	    break;
	case '2': // if player two is chosen
	        printf("two player chosen");
	        r.playernum = 2;
	    break;
	default:
	    usage(argv[0]);
	}
    }
    

if(r.playernum == 1){
player1();
}
  
  


  
  
  
  
  

    // open and create output file
    int fd = open(outFile, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU);
    if (fd < 0) {
	perror("open");
	exit(1);
    }

    int i;
    for (i = 0; i < recordsLeft; i++) {
	// fill in random key
	r.key1 = rand() % (unsigned int) 0xFFFFFFFF;
	// fill in random rest of records
	int j;
	for (j = 0; j < NUMRECS; j++) {
	    r.record[j] = rand() % (int)1e3;
	}

	int rc = write(fd, &r, sizeof(rec_t));
	if (rc != sizeof(rec_t)) {
	    perror("write");
	    exit(1);
	    // should probably remove file here but ...
	}
    }

    // ok to ignore error code here, because we're done anyhow...
    (void) close(fd);

    return 0;
}
